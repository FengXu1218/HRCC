filterfft <- function(f, y, cutoff, wins){
  nf <- length(f)
  ny <- length(y)
  if (ny/2+1 != nf){
    cat('unexpected dimensions of input vectors!')
    y2 <- -1
    return(y2)
  }

  # cutoff filter
  y2 <- zeros(1, ny)
  if (!is.null(cutoff)){
    ind1 <- which(f <= cutoff)
    y2[ind1] = y[ind1]
  } else {
    y2 = y
  }

  # dominant freqs filter
  if (!is.null(wins)){
    temp <- abs(y2[1:nf])
    y2 <- zeros(1, ny)
    for (k in 1:wins){  # number of freqs that I want
      tmax <- max(temp)
      tmaxi <- which.max(temp)
      y2(tmaxi) <- y(tmaxi) # insert required element
      temp(tmaxi) <- 0 # eliminate candidate from list
    }
  }

  # create a conjugate symmetric vector of amplitudes
  for (k in (nf+1):ny){
    y2[k] = Conj(y2[(ny-k+1 %% ny)+1]) # formula from the help of ifft
  }
  return(y2)
}

#' fftf
#'
#'
#' with t the time vector and x the signal,
#' displays the original signal, the Fourier transform (absolute values)
#' and the reconstructed signal generated by the inverse transform ifft
#' with a selected subset of the frequencies.
#' By default, the frequencies in the filtered signal are cut at 1/8 the
#' sampling frequency.
#'
#' @param t time vector
#' @param x the signal
#' @param plot whether to plot
#' @param ...
#'
#' @return The function returns X - reconstructed signal, f - vector of frequencies, y -
#' full vector of amplitudes, y2 - the filtered vector of amplitudes.
#' @export
#'
#' @examples
fftf <- function(t, x, plot = FALSE, ...){
  ## Verifying input
  if (!is.vector(t)){
    cat('Unexpected vector size! - should be 1D vectors.')
    return()
  }
  if (!is.vector(x)){
    cat('Unexpected vector size! - should be 1D vectors.')
    return()
  }
  if (length(t) != length(x)) {
    cat('Unexpected vector size! - should be same length.')
    return()
  }

  ## Definitions
  Fs <- 1/(t[2]-t[1]) # sampling freq
  N <- length(x)
  Nfft <- 2^nextpow2(N)
  f <- Fs/2*seq(0, 1, length.out = (1+Nfft/2)) # create freqs vector
  cutoff_freq <- Fs/8
  my_freqs <- c()
  #cutoff_freq <- 1/(281/3)
  var_args <- list(...)

  if(length(var_args) > 0){
    cutoff_freq = var_args[[1]]
  }
  if(length(var_args) > 1){
    my_freqs = var_args[[2]]
  }

  ## main
  if (Nfft > length(x)) {
    x_new <- c(x, rep(0, Nfft - length(x)))
  } else {
    x_new <- x[1:Nfft]
  }

  y <- fft(x_new)/N # perform fft transform
  y2 <- as.vector(filterfft(f, y, cutoff_freq, my_freqs)) # filter amplitudes
  #X=ifft(y2,'symmetric') # the inverse transform. 'symmetric' is not recognized in older versions of matlab
  X <- as.numeric(ifft(y2)) # inverse transform
  X <- X[1:N]/max(X)
  ind1 <- which(y2[1:(1+Nfft/2)] != 0) # get the nonzero elements in y2
  nf1 <- length(ind1) # count nonzero elements

  ## plot
  yplot <- abs(y[1:(1+Nfft/2)])
  yplot <- log10(yplot/max(yplot))
  data1 <- data.frame(uSec = t*1e6, y = x)
  data2 <- data.frame(MHz = f*1e-6, yplot = yplot)
  data3 <- data.frame(uSec = t*1e6, y_2 = X)

  if (plot == T) {
    # first plot
    mytheme <- theme_bw()+
      theme(panel.grid = element_blank(),
            plot.title = element_text(hjust = 0.5))

    p1 <- ggplot(data1)+
      geom_line(aes(uSec, y), color = "blue")+
      ggtitle('Original signal')+
      ylab("")+
      mytheme

    # second plot
    p2 <- ggplot(data2)+
      geom_line(aes(MHz, yplot), color = "blue")+
      geom_point(data = data2[ind1, ], aes(MHz, yplot), color = "red")+
      scale_y_continuous(breaks = seq(-3, 1, 1), labels = TeX(paste0("$10^{", seq(-3, 1, 1),"}$")))+
      ylab("")+
      ggtitle('Amplitudes')+
      mytheme

    # third plot
    p3 <- ggplot(data3)+
      geom_line(aes(uSec, y_2), color = "blue")+
      ylab("")+
      ggtitle(paste0('Reconstructed signal with', nf1,'selected frequencies',
                     'Cutoff = ', cutoff_freq/1e6, '[Mhz]'))+
      mytheme

    print(p1/p2/p3)
  }

  return(list(X, f, y, y2))
}



#' get_row_order
#'
#' @param fftf2 Matrix after fftf
#'
#' @return
#' @export
#'
#' @examples
get_row_order <- function(fftf2){
  max_index <- apply(fftf2[,(ncol(fftf2)/3+1):(ncol(fftf2)*2/3)], 1, which.max)
  final_index <- order(max_index)
  return(list(max_index,final_index))
}



